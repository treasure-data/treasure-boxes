_export:
# Below, set the variables to include:
# 1) A database name within TD. This value is overwritten for each step, but is required for all td operators. 
# 2) A tablemap_table that maps data staging databases/tables to final data databases/tables (columns: 'staging_table',
#    'staging_database' and 'final_table', 'final_database' respectively).
# Also include any email addresses that should recieve notification of attempted new columns; seperate each value 
# with a comma.
  td:
    database: your_database
    tablemap_table: your_database.staging_to_final_tablemap
      #   example tablemap_table:
      #   |final_table    |final_database    |staging_table   |staging_database  |
      #   |:-------------:|:----------------:|:--------------:|:----------------:|
      #   |example_final  |example_final_db  |example_stage   |example_stageDB   |
      #   |example_final1 |example_final_db  |example_stage1  |example_otherDB   |
    email_warnings: example1@email.com, example2@email.com

# Creates variables for each of the records included in the tablemap_table defined above. These variables are:
# ${td.each.final_table}, ${td.each.final_database}, ${td.each.staging_table}, and ${td.each.staging_database}. 
# The workflow will run once for each record in the tablemap_table.
+for_each_table:
  td_for_each>: sql/each_table_name.sql
  _do:
# A new table will be created with a record for each new column that the staging table has that is not in the final 
# table. If it already exists it will be replaced with the new list of columns being attempted.
    +check_for_new_columns:
      +initialize:
        td_ddl>:
        empty_tables: ["${td.each.final_database}.temp_${td.each.final_table}_column_check"]
      +log_new_columns:
        td>: 
        query: sql/new_columns_log.sql
        insert_into: ${td.each.final_database}.temp_${td.each.final_table}_column_check
      # Outputs count of new columns as variable ${td.last_results.new_column_count}
      +query_count_new_columns:
        td>:
        query: |
          SELECT COUNT(*) AS new_column_count FROM ${td.each.final_database}.temp_${td.each.final_table}_column_check
        store_last_results: true
    
    # Sets value to 'true' if there are new columns
    +email_if_new_columns_or_update_tables_if_no_new_columns:
      if>: ${td.last_results.new_column_count > 0}
      # If new columns, ends an email to whoever is listed in td.email_warnings above letting them know that an attempt 
      # was made to add new columns.
      _do:  
        +send_warning_email:
          mail>:
            data: New column attempting to be added to ${td.each.final_table}. Check table ${td.each.final_database}.temp_${td.each.final_table}_column_check for details.
          subject: New Columns Attempted in ${td.each.final_table} Table.
          to: ['${td.email_warnings}']
      # If no new columns, appends staging data to final data table.
      _else_do:
        +update_table_if_no_new_columns:
          +initialize:
            td_ddl>:
            create_tables: ["${td.each.final_database}.${td.each.final_table}"]
          +append:
            if>: ${td.last_results.new_column_count < 1}
            _do:
              td>:
              query: |
                SELECT * FROM ${td.each.staging_database}.${td.each.staging_table}
              insert_into: "${td.each.final_database}.${td.each.final_table}"
